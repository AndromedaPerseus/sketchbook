/** Generated by v0 */
"use client"

import { useState, useRef, useEffect, useCallback } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Slider } from "@/components/ui/slider"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"

export default function Component() {
  const [isCapturing, setIsCapturing] = useState(false)
  const [fontSize, setFontSize] = useState(10)
  const [asciiChars, setAsciiChars] = useState('@#S%?*+;:,.')
  const [devices, setDevices] = useState<MediaDeviceInfo[]>([])
  const [selectedDevice, setSelectedDevice] = useState<string>('')
  const [resolution, setResolution] = useState<{ width: number; height: number } | null>(null)
  const [downsampleFactor, setDownsampleFactor] = useState(1)
  const videoRef = useRef<HTMLVideoElement>(null)
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const streamRef = useRef<MediaStream | null>(null)
  const animationFrameRef = useRef<number | null>(null)

  const getDevices = useCallback(async () => {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices()
      const videoDevices = devices.filter(device => device.kind === 'videoinput')
      setDevices(videoDevices)
      if (videoDevices.length > 0 && !selectedDevice) {
        setSelectedDevice(videoDevices[0].deviceId)
      }
    } catch (err) {
      console.error("Error enumerating devices:", err)
    }
  }, [selectedDevice])

  useEffect(() => {
    getDevices()
    navigator.mediaDevices.addEventListener('devicechange', getDevices)
    return () => {
      navigator.mediaDevices.removeEventListener('devicechange', getDevices)
    }
  }, [getDevices])

  const startCapture = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { deviceId: selectedDevice ? { exact: selectedDevice } : undefined }
      })
      if (videoRef.current) {
        videoRef.current.srcObject = stream
        await videoRef.current.play()
        setResolution({
          width: videoRef.current.videoWidth,
          height: videoRef.current.videoHeight
        })
      }
      streamRef.current = stream
      setIsCapturing(true)
      animationFrameRef.current = requestAnimationFrame(updateCanvas)
    } catch (err) {
      console.error("Error accessing webcam:", err)
    }
  }

  const stopCapture = () => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop())
      streamRef.current = null
    }
    if (videoRef.current) {
      videoRef.current.srcObject = null
    }
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current)
    }
    setIsCapturing(false)
    setResolution(null)
  }

  const drawAscii = useCallback((ctx: CanvasRenderingContext2D, imageData: ImageData) => {
    const cellWidth = fontSize
    const cellHeight = fontSize
    const numCols = Math.floor(imageData.width / cellWidth)
    const numRows = Math.floor(imageData.height / cellHeight)

    ctx.fillStyle = 'black'
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)

    ctx.font = `${fontSize}px monospace`
    ctx.fillStyle = 'white'

    for (let y = 0; y < numRows; y++) {
      for (let x = 0; x < numCols; x++) {
        const posX = x * cellWidth
        const posY = y * cellHeight

        let totalBrightness = 0
        let sampleCount = 0

        for (let sy = 0; sy < cellHeight; sy++) {
          for (let sx = 0; sx < cellWidth; sx++) {
            const sampleX = posX + sx
            const sampleY = posY + sy
            const offset = (sampleY * imageData.width + sampleX) * 4
            const brightness = (imageData.data[offset] + imageData.data[offset + 1] + imageData.data[offset + 2]) / 3
            totalBrightness += brightness
            sampleCount++
          }
        }

        const averageBrightness = totalBrightness / sampleCount
        const charIndex = Math.floor(averageBrightness / 256 * asciiChars.length)
        const char = asciiChars[charIndex] || ' '

        ctx.fillText(char, posX, posY + cellHeight)
      }
    }
  }, [fontSize, asciiChars])

  const updateCanvas = useCallback(() => {
    if (videoRef.current && canvasRef.current) {
      const video = videoRef.current
      const canvas = canvasRef.current
      const ctx = canvas.getContext('2d')

      if (ctx) {
        const downsampledWidth = Math.floor(video.videoWidth / downsampleFactor)
        const downsampledHeight = Math.floor(video.videoHeight / downsampleFactor)

        canvas.width = downsampledWidth
        canvas.height = downsampledHeight

        ctx.drawImage(video, 0, 0, downsampledWidth, downsampledHeight)

        const imageData = ctx.getImageData(0, 0, downsampledWidth, downsampledHeight)

        drawAscii(ctx, imageData)
      }
    }
    animationFrameRef.current = requestAnimationFrame(updateCanvas)
  }, [drawAscii, downsampleFactor])

  useEffect(() => {
    if (isCapturing) {
      animationFrameRef.current = requestAnimationFrame(updateCanvas)
    }
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
      }
    }
  }, [isCapturing, updateCanvas])

  useEffect(() => {
    return () => {
      if (streamRef.current) {
        streamRef.current.getTracks().forEach(track => track.stop())
      }
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
      }
    }
  }, [])

  return (
    <div className="flex flex-col items-center space-y-4">
      <div className="flex space-x-4">
        <div className="relative w-full max-w-md aspect-video bg-gray-200 rounded-lg overflow-hidden">
          <video
            ref={videoRef}
            className="w-full h-full object-cover"
          />
          {!isCapturing && (
            <div className="absolute inset-0 flex items-center justify-center text-gray-500 bg-gray-200">
              Webcam feed will appear here
            </div>
          )}
        </div>
        <div className="relative w-full max-w-md aspect-video bg-black rounded-lg overflow-hidden">
          <canvas
            ref={canvasRef}
            className="w-full h-full object-contain"
          />
          {!isCapturing && (
            <div className="absolute inset-0 flex items-center justify-center text-gray-500 bg-gray-900">
              ASCII representation will appear here
            </div>
          )}
        </div>
      </div>
      {resolution && (
        <div className="text-sm text-gray-500">
          Webcam Resolution: {resolution.width}x{resolution.height}
          <br />
          Processed Resolution: {Math.floor(resolution.width / downsampleFactor)}x{Math.floor(resolution.height / downsampleFactor)}
        </div>
      )}
      <div className="w-full max-w-2xl space-y-4">
        <div className="space-y-2">
          <Label htmlFor="webcam-select">Select Webcam</Label>
          <Select value={selectedDevice} onValueChange={setSelectedDevice}>
            <SelectTrigger id="webcam-select">
              <SelectValue placeholder="Select a webcam" />
            </SelectTrigger>
            <SelectContent>
              {devices.map((device) => (
                <SelectItem key={device.deviceId} value={device.deviceId}>
                  {device.label || `Webcam ${device.deviceId.slice(0, 5)}`}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
        <div className="space-y-2">
          <Label htmlFor="downsample-factor">Downsample Factor: {downsampleFactor}x</Label>
          <Slider
            id="downsample-factor"
            min={1}
            max={8}
            step={1}
            value={[downsampleFactor]}
            onValueChange={(value) => setDownsampleFactor(value[0])}
          />
        </div>
        <div className="space-y-2">
          <Label htmlFor="font-size">Font Size: {fontSize}px</Label>
          <Slider
            id="font-size"
            min={6}
            max={20}
            step={1}
            value={[fontSize]}
            onValueChange={(value) => setFontSize(value[0])}
          />
        </div>
        <div className="space-y-2">
          <Label htmlFor="ascii-chars">ASCII Characters</Label>
          <Input
            id="ascii-chars"
            value={asciiChars}
            onChange={(e) => setAsciiChars(e.target.value)}
            placeholder="Enter ASCII characters"
          />
        </div>
      </div>
      <Button
        onClick={isCapturing ? stopCapture : startCapture}
        variant={isCapturing ? "destructive" : "default"}
      >
        {isCapturing ? "Stop Capture" : "Start Capture"}
      </Button>
    </div>
  )
}
